---
// ChatCarousel.astro
import "./chatCarousel.scss";

export type Bubble = {
  text: string;
  side?: "left" | "right";
  stickerSrc?: string;
  stickerAlt?: string;

  role?: "user" | "assistant";
  tone?: "text" | "tool" | "info";
  className?: string;
};

export type Slide = {
  id: string;
  heroChip: string;
  nameChip: string;
  characterSrc: string;
  characterAlt?: string;
  avatarSrc?: string;
  bubbles: Bubble[];
};

const {
  slides,
  auto = true,
  heroHoldMs = 1800,
  heroFadeMs = 500,
  bubbleStaggerMs = 2000,
  bubbleFadeMs = 1500,
  endHoldMs = 3000,
  startIndex = 0,
  ariaLabel = "Chat carousel",
} = Astro.props as {
  slides: Slide[];
  auto?: boolean;
  heroHoldMs?: number;
  heroFadeMs?: number;
  bubbleStaggerMs?: number;
  bubbleFadeMs?: number;
  endHoldMs?: number;
  startIndex?: number;
  ariaLabel?: string;
};
---

<section
  class="cc"
  aria-roledescription="carousel"
  aria-label={ariaLabel}
  data-auto={auto ? "1" : "0"}
  data-hero-hold={heroHoldMs}
  data-hero-fade={heroFadeMs}
  data-bubble-stagger={bubbleStaggerMs}
  data-bubble-fade={bubbleFadeMs}
  data-end-hold={endHoldMs}
  data-start-index={startIndex}
>
  <div class="cc__viewport">
    <div class="cc__track">
      {slides.map((s, slideIndex) => (
        <article class="cc__slide" data-slide data-slide-index={slideIndex} aria-roledescription="slide">
          {/* HERO MODULE (chips + character as one unit) */}
          <div class="cc__hero" data-hero>
            <div class="cc__chip cc__chip--top">{s.heroChip}</div>

            <div class="cc__characterWrap" aria-hidden="true">
              <img
                class="cc__character"
                src={s.characterSrc}
                alt={s.characterAlt ?? ""}
                loading="lazy"
                decoding="async"
              />
            </div>

            <div class="cc__chip cc__chip--name">
              {s.avatarSrc ? (
                <img
                  class="cc__avatar"
                  src={s.avatarSrc}
                  alt=""
                  loading="lazy"
                  decoding="async"
                />
              ) : null}
              {s.nameChip}
            </div>
          </div>

          {/* CHAT LAYER */}
          <div class="cc__chat" data-chat aria-hidden="true">
            <div class="cc__chatInner" data-chat-inner>
              {s.bubbles.map((b, bubbleIndex) => (
                <div
                  class={`cc__row ${b.side === "right" ? "is-right" : "is-left"} ${b.role ? `is-${b.role}` : ""}`}
                  data-bubble-row
                  data-bubble-index={bubbleIndex}
                  data-role={b.role ?? ""}
                  data-tone={b.tone ?? ""}
                >
                  <div class={`cc__bubble ${b.className ?? ""} ${b.tone ? `is-${b.tone}` : ""}`} data-bubble>
                    {b.text.split('\n').map((line, i) => (
                    <>
                    {i > 0 && <br />}
                    {line}
                    </>
                    ))}
                    </div>

                  {b.stickerSrc ? (
                    <span class="cc__stickerAnchor" aria-hidden="true">
                    <img
                    class="cc__sticker"
                    src={b.stickerSrc}
                    alt={b.stickerAlt ?? ""}
                    loading="lazy"
                    decoding="async"
                    />
                    </span>
                    ) : null}
                </div>
              ))}
              <div class="cc__chatSpacer" aria-hidden="true"></div>
            </div>
          </div>
        </article>
      ))}
    </div>

    {/* CONTROLS (INSIDE FRAME) */}
    <div class="cc__controls" aria-hidden="false">
      <button class="cc__btn" type="button" data-prev aria-label="Previous slide">‹</button>

      <div class="cc__dots" role="tablist" aria-label="Carousel pagination">
        {slides.map((_, i) => (
          <button
            class="cc__dot"
            type="button"
            data-dot
            data-dot-index={i}
            role="tab"
            aria-label={`Go to slide ${i + 1}`}
          />
        ))}
      </div>

      <button class="cc__btn" type="button" data-next aria-label="Next slide">›</button>
    </div>
  </div>

  <script is:inline>
    (() => {
      const root = document.currentScript.closest(".cc");
      if (!root) return;

      const track = root.querySelector(".cc__track");
      const slideEls = Array.from(root.querySelectorAll("[data-slide]"));
      const dots = Array.from(root.querySelectorAll("[data-dot]"));
      const prevBtn = root.querySelector("[data-prev]");
      const nextBtn = root.querySelector("[data-next]");

      const auto = root.dataset.auto === "1";
      const heroHoldMs = Number(root.dataset.heroHold) || 2000;
      const heroFadeMs = Number(root.dataset.heroFade) || 500;
      const bubbleStaggerMs = Number(root.dataset.bubbleStagger) || 1500;
      const bubbleFadeMs = Number(root.dataset.bubbleFade) || 1500;
      const endHoldMs = Number(root.dataset.endHold) || 2000;
      const startIndex = Math.min(
        Math.max(Number(root.dataset.startIndex) || 0, 0),
        slideEls.length - 1
      );

      let index = startIndex;
      let timers = [];

      const clearTimers = () => {
        timers.forEach((t) => clearTimeout(t));
        timers = [];
      };

      const setDotState = (i) => {
        dots.forEach((d, di) => d.setAttribute("aria-selected", di === i ? "true" : "false"));
      };

      const setTrack = (i, animate = true) => {
        if (!track) return;
        if (!animate) track.style.transition = "none";
        track.style.transform = `translate3d(${-i * 100}%, 0, 0)`;
        if (!animate) requestAnimationFrame(() => (track.style.transition = ""));
      };

      // Robust: use scrollHeight (includes padding + late-loading images)
      const updateChatOffset = (slideEl) => {
        const viewport = slideEl.querySelector("[data-chat]");
        const inner = slideEl.querySelector("[data-chat-inner]");
        if (!viewport || !inner) return;

        const overflow = Math.max(0, inner.scrollHeight - viewport.clientHeight);
        inner.style.transform = `translateY(${-overflow}px)`;
      };

      const resetSlideVisuals = (slideEl) => {
        slideEl.classList.remove("is-hero-fading", "is-chat-live");
        slideEl.querySelectorAll("[data-bubble-row]").forEach((r) => r.classList.remove("is-mounted", "is-visible"));

        const chat = slideEl.querySelector("[data-chat]");
        if (chat) chat.setAttribute("aria-hidden", "true");

        const inner = slideEl.querySelector("[data-chat-inner]");
        if (inner) inner.style.transform = "translateY(0px)";
      };

      const mountAndAnimateRow = (row, slideEl) => {
        row.classList.add("is-mounted");
        row.offsetHeight; // force reflow so transition fires
        row.classList.add("is-visible");

        requestAnimationFrame(() => updateChatOffset(slideEl));

        // if sticker loads later, update offset
        const imgs = row.querySelectorAll("img");
        imgs.forEach((img) => {
          if (!img.complete) img.addEventListener("load", () => updateChatOffset(slideEl), { once: true });
        });

        // one more pass after fade
        setTimeout(() => updateChatOffset(slideEl), Math.max(0, bubbleFadeMs - 16));
      };

      const runSequence = (slideEl) => {
        clearTimers();
        slideEls.forEach((s) => resetSlideVisuals(s));

        const t1 = setTimeout(() => {
          slideEl.classList.add("is-hero-fading");
        }, heroHoldMs);
        timers.push(t1);

        const t2 = setTimeout(() => {
          slideEl.classList.add("is-chat-live");
          const chat = slideEl.querySelector("[data-chat]");
          if (chat) chat.setAttribute("aria-hidden", "false");

          requestAnimationFrame(() => updateChatOffset(slideEl));

          const rows = Array.from(slideEl.querySelectorAll("[data-bubble-row]"));
          rows.forEach((row, i) => {
            const ti = setTimeout(() => mountAndAnimateRow(row, slideEl), i * bubbleStaggerMs);
            timers.push(ti);
          });

          if (auto) {
            const total = rows.length * bubbleStaggerMs + endHoldMs;
            const tNext = setTimeout(() => goTo(index + 1, true), total);
            timers.push(tNext);
          }
        }, heroHoldMs + heroFadeMs);
        timers.push(t2);
      };

      const goTo = (next, _fromAuto = false) => {
        if (!slideEls.length) return;

        if (next < 0) next = slideEls.length - 1;
        if (next >= slideEls.length) next = 0;

        index = next;
        setTrack(index, true);
        setDotState(index);
        runSequence(slideEls[index]);
      };

      // Controls ONLY (no drag/swipe). Clicking chat does nothing.
      prevBtn?.addEventListener("click", () => goTo(index - 1));
      nextBtn?.addEventListener("click", () => goTo(index + 1));
      dots.forEach((d) => d.addEventListener("click", () => goTo(Number(d.dataset.dotIndex || "0"))));

      // Init
      setTrack(startIndex, false);
      setDotState(startIndex);
      runSequence(slideEls[startIndex]);
    })();
  </script>
</section>